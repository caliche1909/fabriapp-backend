const Sequelize = require('sequelize');

module.exports = function(sequelize, DataTypes) {
  // üìå MODELO PARA REPORTES DE NO-VENTA
  // Corresponde a la tabla: public.store_no_sale_reports
  // Almacena reportes detallados cuando no se pudo realizar una venta en una tienda
  // con informaci√≥n sobre la categor√≠a, raz√≥n, comentarios y datos del cliente
  const StoreNoSaleReports = sequelize.define('store_no_sale_reports', {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      allowNull: false,
      primaryKey: true,
      comment: 'Identificador √∫nico del reporte de no-venta'
    },
    visit_id: {
      type: DataTypes.INTEGER,
      allowNull: true,
      references: {
        model: 'store_visits',
        key: 'id'
      },
      comment: 'Referencia opcional a la visita espec√≠fica donde se gener√≥ el reporte (FK a store_visits)',
      validate: {
        // üîç VALIDACI√ìN: Asegurar que no haya reportes duplicados por visita
        // Ejemplo de uso: Al crear un reporte desde una visita espec√≠fica
        async isUniqueVisitReport(value) {
          if (value !== null && value !== undefined) {
            const existingReport = await StoreNoSaleReports.findOne({
              where: {
                visit_id: value,
                id: { [sequelize.Sequelize.Op.ne]: this.id || 0 }
              }
            });
            if (existingReport) {
              throw new Error('Ya existe un reporte de no-venta para esta visita');
            }
          }
        }
      }
    },
    store_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'stores',
        key: 'id'
      },
      comment: 'ID de la tienda donde ocurri√≥ la no-venta (FK a stores) - REQUERIDO',
      validate: {
        notNull: {
          msg: 'El ID de la tienda es requerido'
        }
      }
    },
    user_id: {
      type: DataTypes.UUID,
      allowNull: false,
      references: {
        model: 'users',
        key: 'id'
      },
      comment: 'ID del usuario que reporta la no-venta (FK a users) - REQUERIDO',
      validate: {
        notNull: {
          msg: 'El ID del usuario es requerido'
        }
      }
    },
    route_id: {
      type: DataTypes.INTEGER,
      allowNull: true,
      references: {
        model: 'routes',
        key: 'id'
      },
      comment: 'Referencia opcional a la ruta en la que se encontraba el usuario (FK a routes)'
    },
    company_id: {
      type: DataTypes.UUID,
      allowNull: false,
      references: {
        model: 'companies',
        key: 'id'
      },
      comment: 'ID de la compa√±√≠a a la que pertenece el reporte (FK a companies) - REQUERIDO',
      validate: {
        notNull: {
          msg: 'El ID de la compa√±√≠a es requerido'
        }
      }
    },
    category_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'no_sale_categories',
        key: 'id'
      },
      comment: 'ID de la categor√≠a de no-venta (FK a no_sale_categories) - REQUERIDO',
      validate: {
        notNull: {
          msg: 'El ID de la categor√≠a es requerido'
        }
      }
    },
    reason_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'no_sale_reasons',
        key: 'id'
      },
      comment: 'ID de la raz√≥n espec√≠fica de no-venta (FK a no_sale_reasons) - REQUERIDO',
      validate: {
        notNull: {
          msg: 'El ID de la raz√≥n es requerido'
        }
      }
    },
    comments: {
      type: DataTypes.TEXT,
      allowNull: false,
      comment: 'Comentarios detallados del usuario sobre la situaci√≥n de no-venta - REQUERIDO',
      validate: {
        notNull: {
          msg: 'Los comentarios son requeridos'
        },
        notEmpty: {
          msg: 'Los comentarios no pueden estar vac√≠os'
        },
        len: {
          args: [1, 2000],
          msg: 'Los comentarios deben tener entre 1 y 2000 caracteres'
        }
      }
    },
    client_name: {
      type: DataTypes.STRING(255),
      allowNull: true,
      comment: 'Nombre del cliente contactado (opcional, m√°ximo 255 caracteres)',
      validate: {
        len: {
          args: [0, 255],
          msg: 'El nombre del cliente no puede exceder 255 caracteres'
        }
      }
    },
    client_phone: {
      type: DataTypes.STRING(20),
      allowNull: true,
      comment: 'Tel√©fono del cliente contactado (opcional, m√°ximo 20 caracteres)',
      validate: {
        len: {
          args: [0, 20],
          msg: 'El tel√©fono del cliente no puede exceder 20 caracteres'
        },
        // üîç VALIDACI√ìN: Formato b√°sico de tel√©fono
        // Ejemplo de uso: Validar formato antes de guardar
        isPhoneFormat(value) {
          if (value && value.trim() !== '') {
            const phoneRegex = /^[+]?[0-9\s\-\(\)]{7,20}$/;
            if (!phoneRegex.test(value)) {
              throw new Error('El formato del tel√©fono no es v√°lido');
            }
          }
        }
      }
    },
    created_at: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
      comment: 'Fecha y hora de creaci√≥n del reporte (timestamp with time zone)'
    },
    updated_at: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
      comment: 'Fecha y hora de √∫ltima actualizaci√≥n (actualizada autom√°ticamente por trigger)'
    }
  }, {
    sequelize,
    tableName: 'store_no_sale_reports',
    schema: 'public',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    freezeTableName: true,
    hasTrigger: true, // ‚úÖ Trigger set_timestamp_store_no_sale_reports actualiza updated_at
    indexes: [
      {
        name: "store_no_sale_reports_pkey",
        unique: true,
        fields: [{ name: "id" }]
      },
      {
        name: "idx_store_no_sale_reports_category",
        fields: [{ name: "category_id" }]
      },
      {
        name: "idx_store_no_sale_reports_category_company_date",
        fields: [
          { name: "category_id" },
          { name: "company_id" },
          { name: "created_at", order: "DESC" }
        ]
      },
      {
        name: "idx_store_no_sale_reports_company_date",
        fields: [
          { name: "company_id" },
          { name: "created_at", order: "DESC" }
        ]
      },
      {
        name: "idx_store_no_sale_reports_reason",
        fields: [{ name: "reason_id" }]
      },
      {
        name: "idx_store_no_sale_reports_reason_company_date",
        fields: [
          { name: "reason_id" },
          { name: "company_id" },
          { name: "created_at", order: "DESC" }
        ]
      },
      {
        name: "idx_store_no_sale_reports_route_date",
        fields: [
          { name: "route_id" },
          { name: "created_at", order: "DESC" }
        ],
        where: {
          route_id: { [sequelize.Sequelize.Op.ne]: null }
        }
      },
      {
        name: "idx_store_no_sale_reports_store_date",
        fields: [
          { name: "store_id" },
          { name: "created_at", order: "DESC" }
        ]
      },
      {
        name: "idx_store_no_sale_reports_user_date",
        fields: [
          { name: "user_id" },
          { name: "created_at", order: "DESC" }
        ]
      },
      {
        name: "idx_store_no_sale_reports_visit",
        fields: [{ name: "visit_id" }],
        where: {
          visit_id: { [sequelize.Sequelize.Op.ne]: null }
        }
      },
      {
        name: "idx_unique_visit_report",
        unique: true,
        fields: [{ name: "visit_id" }],
        where: {
          visit_id: { [sequelize.Sequelize.Op.ne]: null }
        }
      }
    ]
  });

  // ÔøΩ DEFINICI√ìN DE RELACIONES/ASOCIACIONES
  StoreNoSaleReports.associate = function(models) {
    // üè™ Relaci√≥n con Stores - Un reporte pertenece a una tienda
    StoreNoSaleReports.belongsTo(models.stores, {
      as: 'store',
      foreignKey: 'store_id',
      onDelete: 'RESTRICT',
      onUpdate: 'CASCADE'
    });

    // üë§ Relaci√≥n con Users - Un reporte pertenece a un usuario (quien lo cre√≥)
    StoreNoSaleReports.belongsTo(models.users, {
      as: 'user',
      foreignKey: 'user_id',
      onDelete: 'RESTRICT',
      onUpdate: 'CASCADE'
    });

    // üõ£Ô∏è Relaci√≥n con Routes - Un reporte puede pertenecer a una ruta (opcional)
    StoreNoSaleReports.belongsTo(models.routes, {
      as: 'route',
      foreignKey: 'route_id',
      onDelete: 'SET NULL',
      onUpdate: 'CASCADE'
    });

    // üè¢ Relaci√≥n con Companies - Un reporte pertenece a una compa√±√≠a
    StoreNoSaleReports.belongsTo(models.companies, {
      as: 'company',
      foreignKey: 'company_id',
      onDelete: 'RESTRICT',
      onUpdate: 'CASCADE'
    });

    // üìÇ Relaci√≥n con NoSaleCategories - Un reporte pertenece a una categor√≠a
    StoreNoSaleReports.belongsTo(models.no_sale_categories, {
      as: 'category',
      foreignKey: 'category_id',
      onDelete: 'RESTRICT',
      onUpdate: 'CASCADE'
    });

    // üìã Relaci√≥n con NoSaleReasons - Un reporte pertenece a una raz√≥n espec√≠fica
    StoreNoSaleReports.belongsTo(models.no_sale_reasons, {
      as: 'reason',
      foreignKey: 'reason_id',
      onDelete: 'RESTRICT',
      onUpdate: 'CASCADE'
    });

    // üö∂ Relaci√≥n con StoreVisits - Un reporte puede estar asociado a una visita (opcional)
    StoreNoSaleReports.belongsTo(models.store_visits, {
      as: 'visit',
      foreignKey: 'visit_id',
      onDelete: 'SET NULL',
      onUpdate: 'CASCADE'
    });
  };

  // ÔøΩüîß M√âTODOS DE INSTANCIA
  
  /**
   * üìù M√âTODO: toJSON - Personalizar serializaci√≥n JSON
   * üéØ Prop√≥sito: Formatear fechas y datos para respuestas API
   * üìã Ejemplo de uso:
   *    const report = await StoreNoSaleReports.findByPk(1);
   *    const jsonData = report.toJSON(); // Fechas en formato ISO
   */
  StoreNoSaleReports.prototype.toJSON = function() {
    const values = { ...this.get() };
    
    // Formatear fechas si es necesario
    if (values.created_at) {
      values.created_at = values.created_at.toISOString();
    }
    if (values.updated_at) {
      values.updated_at = values.updated_at.toISOString();
    }
    
    return values;
  };

  /**
   * ‚úÖ M√âTODO: validateCategoryReason - Validar compatibilidad categor√≠a-raz√≥n
   * üéØ Prop√≥sito: Asegurar que la raz√≥n seleccionada pertenece a la categor√≠a
   * üìã Ejemplo de uso:
   *    const report = new StoreNoSaleReports({category_id: 1, reason_id: 5});
   *    await report.validateCategoryReason(); // Valida antes de guardar
   */
  StoreNoSaleReports.prototype.validateCategoryReason = async function() {
    const reason = await sequelize.models.no_sale_reasons.findByPk(this.reason_id);
    if (!reason || reason.category_id !== this.category_id) {
      throw new Error('La raz√≥n seleccionada no pertenece a la categor√≠a especificada');
    }
    return true;
  };

  /**
   * üè¢ M√âTODO: validateCategoryForCompany - Validar categor√≠a para compa√±√≠a
   * üéØ Prop√≥sito: Verificar que la categor√≠a est√© disponible para la compa√±√≠a (global o propia)
   * üìã Ejemplo de uso:
   *    const report = new StoreNoSaleReports({category_id: 1, company_id: 'uuid-123'});
   *    await report.validateCategoryForCompany(); // Valida acceso a la categor√≠a
   */
  StoreNoSaleReports.prototype.validateCategoryForCompany = async function() {
    const category = await sequelize.models.no_sale_categories.findByPk(this.category_id);
    if (!category) {
      throw new Error('La categor√≠a especificada no existe');
    }
    
    // Si la categor√≠a no es global, debe pertenecer a la compa√±√≠a
    if (!category.is_global && category.company_id !== this.company_id) {
      throw new Error('La categor√≠a seleccionada no est√° disponible para esta compa√±√≠a');
    }
    
    return true;
  };

  // üîç M√âTODOS EST√ÅTICOS DE CONSULTA

  /**
   * üè¢ M√âTODO: findByCompany - Buscar reportes por compa√±√≠a
   * üéØ Prop√≥sito: Obtener todos los reportes de no-venta de una compa√±√≠a espec√≠fica
   * üìã Ejemplo de uso:
   *    const reports = await StoreNoSaleReports.findByCompany('company-uuid-123', {
   *      limit: 50,
   *      include: ['store', 'user', 'category', 'reason']
   *    });
   */
  StoreNoSaleReports.findByCompany = async function(companyId, options = {}) {
    return await this.findAll({
      where: {
        company_id: companyId,
        ...options.where
      },
      include: options.include || [
        { model: sequelize.models.stores, as: 'store' },
        { model: sequelize.models.users, as: 'user' },
        { model: sequelize.models.no_sale_categories, as: 'category' },
        { model: sequelize.models.no_sale_reasons, as: 'reason' },
        { model: sequelize.models.routes, as: 'route', required: false },
        { model: sequelize.models.store_visits, as: 'visit', required: false }
      ],
      order: options.order || [['created_at', 'DESC']],
      limit: options.limit,
      offset: options.offset
    });
  };

  /**
   * üë§ M√âTODO: findByUser - Buscar reportes por usuario
   * üéØ Prop√≥sito: Obtener todos los reportes creados por un usuario espec√≠fico
   * üìã Ejemplo de uso:
   *    const userReports = await StoreNoSaleReports.findByUser('user-uuid-456', {
   *      where: { created_at: { [Op.gte]: new Date('2024-01-01') } }
   *    });
   */
  StoreNoSaleReports.findByUser = async function(userId, options = {}) {
    return await this.findAll({
      where: {
        user_id: userId,
        ...options.where
      },
      include: options.include || [
        { model: sequelize.models.stores, as: 'store' },
        { model: sequelize.models.no_sale_categories, as: 'category' },
        { model: sequelize.models.no_sale_reasons, as: 'reason' }
      ],
      order: options.order || [['created_at', 'DESC']],
      limit: options.limit,
      offset: options.offset
    });
  };

  /**
   * üè™ M√âTODO: findByStore - Buscar reportes por tienda
   * üéØ Prop√≥sito: Obtener historial de reportes de no-venta de una tienda espec√≠fica
   * üìã Ejemplo de uso:
   *    const storeReports = await StoreNoSaleReports.findByStore(123, {
   *      limit: 20,
   *      order: [['created_at', 'DESC']]
   *    });
   */
  StoreNoSaleReports.findByStore = async function(storeId, options = {}) {
    return await this.findAll({
      where: {
        store_id: storeId,
        ...options.where
      },
      include: options.include || [
        { model: sequelize.models.users, as: 'user' },
        { model: sequelize.models.no_sale_categories, as: 'category' },
        { model: sequelize.models.no_sale_reasons, as: 'reason' }
      ],
      order: options.order || [['created_at', 'DESC']],
      limit: options.limit,
      offset: options.offset
    });
  };

  /**
   * üìÇ M√âTODO: findByCategory - Buscar reportes por categor√≠a
   * üéØ Prop√≥sito: Analizar reportes de una categor√≠a espec√≠fica de no-venta
   * üìã Ejemplo de uso:
   *    const categoryReports = await StoreNoSaleReports.findByCategory(1, {
   *      where: { company_id: 'company-uuid' },
   *      include: ['reason', 'store']
   *    });
   */
  StoreNoSaleReports.findByCategory = async function(categoryId, options = {}) {
    return await this.findAll({
      where: {
        category_id: categoryId,
        ...options.where
      },
      include: options.include || [
        { model: sequelize.models.stores, as: 'store' },
        { model: sequelize.models.users, as: 'user' },
        { model: sequelize.models.no_sale_reasons, as: 'reason' }
      ],
      order: options.order || [['created_at', 'DESC']],
      limit: options.limit,
      offset: options.offset
    });
  };

  /**
   * üìÖ M√âTODO: findByDateRange - Buscar reportes por rango de fechas
   * üéØ Prop√≥sito: Consultar reportes en un per√≠odo espec√≠fico para an√°lisis temporal
   * üìã Ejemplo de uso:
   *    const monthlyReports = await StoreNoSaleReports.findByDateRange(
   *      new Date('2024-01-01'),
   *      new Date('2024-01-31'),
   *      { where: { company_id: 'company-uuid' } }
   *    );
   */
  StoreNoSaleReports.findByDateRange = async function(startDate, endDate, options = {}) {
    return await this.findAll({
      where: {
        created_at: {
          [sequelize.Sequelize.Op.between]: [startDate, endDate]
        },
        ...options.where
      },
      include: options.include || [
        { model: sequelize.models.stores, as: 'store' },
        { model: sequelize.models.users, as: 'user' },
        { model: sequelize.models.no_sale_categories, as: 'category' },
        { model: sequelize.models.no_sale_reasons, as: 'reason' }
      ],
      order: options.order || [['created_at', 'DESC']],
      limit: options.limit,
      offset: options.offset
    });
  };

  /**
   * üìä M√âTODO: getStatsByCategory - Estad√≠sticas por categor√≠a
   * üéØ Prop√≥sito: Generar estad√≠sticas agregadas de reportes agrupados por categor√≠a
   * üìã Ejemplo de uso:
   *    const stats = await StoreNoSaleReports.getStatsByCategory('company-uuid', {
   *      startDate: new Date('2024-01-01'),
   *      endDate: new Date('2024-12-31')
   *    });
   *    // Resultado: [{category_name: 'Cliente no disponible', total_reports: 25, affected_stores: 15}]
   */
  StoreNoSaleReports.getStatsByCategory = async function(companyId, options = {}) {
    const { startDate, endDate } = options;
    
    const whereCondition = {
      company_id: companyId
    };
    
    if (startDate && endDate) {
      whereCondition.created_at = {
        [sequelize.Sequelize.Op.between]: [startDate, endDate]
      };
    }
    
    return await this.findAll({
      attributes: [
        'category_id',
        [sequelize.fn('COUNT', '*'), 'total_reports'],
        [sequelize.fn('COUNT', sequelize.fn('DISTINCT', sequelize.col('store_id'))), 'affected_stores'],
        [sequelize.fn('COUNT', sequelize.fn('DISTINCT', sequelize.col('user_id'))), 'reporting_users']
      ],
      where: whereCondition,
      include: [
        {
          model: sequelize.models.no_sale_categories,
          as: 'category',
          attributes: ['name', 'description']
        }
      ],
      group: ['category_id', 'category.id'],
      order: [[sequelize.literal('total_reports'), 'DESC']]
    });
  };

  /**
   * ‚úçÔ∏è M√âTODO: createReport - Crear reporte con validaciones completas
   * üéØ Prop√≥sito: Crear un nuevo reporte asegurando todas las validaciones de integridad
   * üìã Ejemplo de uso:
   *    const reportData = {
   *      store_id: 123,
   *      user_id: 'user-uuid',
   *      company_id: 'company-uuid',
   *      category_id: 1,
   *      reason_id: 3,
   *      comments: 'Cliente no estaba disponible en el momento de la visita',
   *      client_name: 'Juan P√©rez',
   *      client_phone: '+573001234567'
   *    };
   *    const newReport = await StoreNoSaleReports.createReport(reportData);
   */
  StoreNoSaleReports.createReport = async function(reportData, options = {}) {
    const transaction = options.transaction || await sequelize.transaction();
    
    try {
      // Crear la instancia del reporte
      const report = this.build(reportData);
      
      // Validar categor√≠a para la compa√±√≠a
      await report.validateCategoryForCompany();
      
      // Validar que la raz√≥n pertenezca a la categor√≠a
      await report.validateCategoryReason();
      
      // Guardar el reporte
      await report.save({ transaction });
      
      // Si no se pas√≥ una transacci√≥n externa, hacer commit
      if (!options.transaction) {
        await transaction.commit();
      }
      
      return report;
    } catch (error) {
      // Si no se pas√≥ una transacci√≥n externa, hacer rollback
      if (!options.transaction) {
        await transaction.rollback();
      }
      throw error;
    }
  };

  /**
   * üìà M√âTODO: getReportsByReason - Reportes agrupados por raz√≥n
   * üéØ Prop√≥sito: Analizar cu√°les son las razones m√°s comunes de no-venta
   * üìã Ejemplo de uso:
   *    const reasonStats = await StoreNoSaleReports.getReportsByReason('company-uuid', {
   *      category_id: 1, // Filtrar por categor√≠a espec√≠fica
   *      limit: 10 // Top 10 razones
   *    });
   */
  StoreNoSaleReports.getReportsByReason = async function(companyId, options = {}) {
    const whereCondition = {
      company_id: companyId,
      ...options.where
    };

    return await this.findAll({
      attributes: [
        'reason_id',
        [sequelize.fn('COUNT', '*'), 'total_reports'],
        [sequelize.fn('COUNT', sequelize.fn('DISTINCT', sequelize.col('store_id'))), 'unique_stores']
      ],
      where: whereCondition,
      include: [
        {
          model: sequelize.models.no_sale_reasons,
          as: 'reason',
          attributes: ['name', 'description']
        },
        {
          model: sequelize.models.no_sale_categories,
          as: 'category',
          attributes: ['name']
        }
      ],
      group: ['reason_id', 'reason.id', 'category.id'],
      order: [[sequelize.literal('total_reports'), 'DESC']],
      limit: options.limit || 20
    });
  };

  /**
   * üö® M√âTODO: findProblematicStores - Tiendas con m√°s reportes de no-venta
   * üéØ Prop√≥sito: Identificar tiendas que requieren atenci√≥n especial
   * üìã Ejemplo de uso:
   *    const problematicStores = await StoreNoSaleReports.findProblematicStores('company-uuid', {
   *      minReports: 5, // M√≠nimo 5 reportes para considerarse problem√°tica
   *      days: 30 // En los √∫ltimos 30 d√≠as
   *    });
   */
  StoreNoSaleReports.findProblematicStores = async function(companyId, options = {}) {
    const { minReports = 3, days = 30 } = options;
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    return await this.findAll({
      attributes: [
        'store_id',
        [sequelize.fn('COUNT', '*'), 'total_reports'],
        [sequelize.fn('COUNT', sequelize.fn('DISTINCT', sequelize.col('category_id'))), 'different_categories'],
        [sequelize.fn('MAX', sequelize.col('store_no_sale_reports.created_at')), 'last_report_date']
      ],
      where: {
        company_id: companyId,
        created_at: {
          [sequelize.Sequelize.Op.gte]: startDate
        }
      },
      include: [
        {
          model: sequelize.models.stores,
          as: 'store',
          attributes: ['name', 'address', 'phone']
        }
      ],
      group: ['store_id', 'store.id'],
      having: sequelize.where(sequelize.fn('COUNT', '*'), '>=', minReports),
      order: [[sequelize.literal('total_reports'), 'DESC']]
    });
  };

  /**
   * üìã M√âTODO: findByVisit - Buscar reporte por visita espec√≠fica
   * üéØ Prop√≥sito: Obtener el reporte asociado a una visita de tienda
   * üìã Ejemplo de uso:
   *    const visitReport = await StoreNoSaleReports.findByVisit(visitId);
   *    if (visitReport) {
   *      console.log('Esta visita ya tiene un reporte de no-venta');
   *    }
   */
  StoreNoSaleReports.findByVisit = async function(visitId) {
    return await this.findOne({
      where: { visit_id: visitId },
      include: [
        { model: sequelize.models.no_sale_categories, as: 'category' },
        { model: sequelize.models.no_sale_reasons, as: 'reason' },
        { model: sequelize.models.stores, as: 'store' },
        { model: sequelize.models.users, as: 'user' }
      ]
    });
  };

  return StoreNoSaleReports;
};